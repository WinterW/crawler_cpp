/**
 * Autogenerated by Thrift Compiler (0.9.1)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef conf_crawler_TYPES_H
#define conf_crawler_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>




struct TemplateType {
  enum type {
    CSS_SELECTOR_TYPE = 0,
    PLAIN_HTML_TYPE = 1,
    RELAY_TYPE = 2,
    TEMPLATE_TYPE_MAX = 3,
    NONE_TYPE = 10000
  };
};

extern const std::map<int, const char*> _TemplateType_VALUES_TO_NAMES;

struct HeaderFieldsType {
  enum type {
    DEFAULT_TYPE = 0,
    UPDATE_PART_TYPE = 1,
    UPDATE_ALL_TYPE = 2,
    HEADER_FIELDS_TYPE_MAX = 3,
    NONE_TYPE = 10000
  };
};

extern const std::map<int, const char*> _HeaderFieldsType_VALUES_TO_NAMES;

struct DownloaderType {
  enum type {
    NORMAL_TYPE = 0,
    WEBKIT_TYPE = 1,
    DOWNLOADER_TYPE_MAX = 2,
    NONE_TYPE = 10000
  };
};

extern const std::map<int, const char*> _DownloaderType_VALUES_TO_NAMES;

typedef struct _DownloadReqItem__isset {
  _DownloadReqItem__isset() : url(false), ip(false), referer(false), ua(false), header_fields_type(false), downloader_type(false), post_fields(false), time_out(false) {}
  bool url;
  bool ip;
  bool referer;
  bool ua;
  bool header_fields_type;
  bool downloader_type;
  bool post_fields;
  bool time_out;
} _DownloadReqItem__isset;

class DownloadReqItem {
 public:

  static const char* ascii_fingerprint; // = "A05424282DCCCACB2DED38CF74AAFF0B";
  static const uint8_t binary_fingerprint[16]; // = {0xA0,0x54,0x24,0x28,0x2D,0xCC,0xCA,0xCB,0x2D,0xED,0x38,0xCF,0x74,0xAA,0xFF,0x0B};

  DownloadReqItem() : url(), ip(), referer(), ua(), header_fields_type((HeaderFieldsType::type)0), downloader_type((DownloaderType::type)0), post_fields(), time_out(0) {
  }

  virtual ~DownloadReqItem() throw() {}

  std::string url;
  std::string ip;
  std::string referer;
  std::string ua;
  HeaderFieldsType::type header_fields_type;
  DownloaderType::type downloader_type;
  std::string post_fields;
  int32_t time_out;

  _DownloadReqItem__isset __isset;

  void __set_url(const std::string& val) {
    url = val;
  }

  void __set_ip(const std::string& val) {
    ip = val;
  }

  void __set_referer(const std::string& val) {
    referer = val;
  }

  void __set_ua(const std::string& val) {
    ua = val;
  }

  void __set_header_fields_type(const HeaderFieldsType::type val) {
    header_fields_type = val;
  }

  void __set_downloader_type(const DownloaderType::type val) {
    downloader_type = val;
  }

  void __set_post_fields(const std::string& val) {
    post_fields = val;
  }

  void __set_time_out(const int32_t val) {
    time_out = val;
  }

  bool operator == (const DownloadReqItem & rhs) const
  {
    if (!(url == rhs.url))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(referer == rhs.referer))
      return false;
    if (!(ua == rhs.ua))
      return false;
    if (!(header_fields_type == rhs.header_fields_type))
      return false;
    if (!(downloader_type == rhs.downloader_type))
      return false;
    if (!(post_fields == rhs.post_fields))
      return false;
    if (!(time_out == rhs.time_out))
      return false;
    return true;
  }
  bool operator != (const DownloadReqItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadReqItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DownloadReqItem &a, DownloadReqItem &b);

typedef struct _DownloadPropItem__isset {
  _DownloadPropItem__isset() : is_img(false), is_friendly(false), interval(false), retry_times(false), seed_url(false), depth(false) {}
  bool is_img;
  bool is_friendly;
  bool interval;
  bool retry_times;
  bool seed_url;
  bool depth;
} _DownloadPropItem__isset;

class DownloadPropItem {
 public:

  static const char* ascii_fingerprint; // = "DA6BC29B6C0C31F6833671FA32698E6B";
  static const uint8_t binary_fingerprint[16]; // = {0xDA,0x6B,0xC2,0x9B,0x6C,0x0C,0x31,0xF6,0x83,0x36,0x71,0xFA,0x32,0x69,0x8E,0x6B};

  DownloadPropItem() : is_img(0), is_friendly(0), interval(0), retry_times(0), seed_url(), depth(0) {
  }

  virtual ~DownloadPropItem() throw() {}

  bool is_img;
  bool is_friendly;
  int32_t interval;
  int32_t retry_times;
  std::string seed_url;
  int32_t depth;

  _DownloadPropItem__isset __isset;

  void __set_is_img(const bool val) {
    is_img = val;
  }

  void __set_is_friendly(const bool val) {
    is_friendly = val;
  }

  void __set_interval(const int32_t val) {
    interval = val;
  }

  void __set_retry_times(const int32_t val) {
    retry_times = val;
  }

  void __set_seed_url(const std::string& val) {
    seed_url = val;
  }

  void __set_depth(const int32_t val) {
    depth = val;
  }

  bool operator == (const DownloadPropItem & rhs) const
  {
    if (!(is_img == rhs.is_img))
      return false;
    if (!(is_friendly == rhs.is_friendly))
      return false;
    if (!(interval == rhs.interval))
      return false;
    if (!(retry_times == rhs.retry_times))
      return false;
    if (!(seed_url == rhs.seed_url))
      return false;
    if (!(depth == rhs.depth))
      return false;
    return true;
  }
  bool operator != (const DownloadPropItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadPropItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DownloadPropItem &a, DownloadPropItem &b);

typedef struct _DownloadTask__isset {
  _DownloadTask__isset() : req_item(false), prop_item(false) {}
  bool req_item;
  bool prop_item;
} _DownloadTask__isset;

class DownloadTask {
 public:

  static const char* ascii_fingerprint; // = "C4556DAEF10E1FC938DF5C37EE9C91AA";
  static const uint8_t binary_fingerprint[16]; // = {0xC4,0x55,0x6D,0xAE,0xF1,0x0E,0x1F,0xC9,0x38,0xDF,0x5C,0x37,0xEE,0x9C,0x91,0xAA};

  DownloadTask() {
  }

  virtual ~DownloadTask() throw() {}

  DownloadReqItem req_item;
  DownloadPropItem prop_item;

  _DownloadTask__isset __isset;

  void __set_req_item(const DownloadReqItem& val) {
    req_item = val;
  }

  void __set_prop_item(const DownloadPropItem& val) {
    prop_item = val;
  }

  bool operator == (const DownloadTask & rhs) const
  {
    if (!(req_item == rhs.req_item))
      return false;
    if (!(prop_item == rhs.prop_item))
      return false;
    return true;
  }
  bool operator != (const DownloadTask &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadTask & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DownloadTask &a, DownloadTask &b);

typedef struct _DownloadedBodyItem__isset {
  _DownloadedBodyItem__isset() : req_item(false), prop_item(false), is_ok(false), body(false) {}
  bool req_item;
  bool prop_item;
  bool is_ok;
  bool body;
} _DownloadedBodyItem__isset;

class DownloadedBodyItem {
 public:

  static const char* ascii_fingerprint; // = "35ACADBED69F1B9DCBDF206A2E9EA0E5";
  static const uint8_t binary_fingerprint[16]; // = {0x35,0xAC,0xAD,0xBE,0xD6,0x9F,0x1B,0x9D,0xCB,0xDF,0x20,0x6A,0x2E,0x9E,0xA0,0xE5};

  DownloadedBodyItem() : is_ok(0), body() {
  }

  virtual ~DownloadedBodyItem() throw() {}

  DownloadReqItem req_item;
  DownloadPropItem prop_item;
  bool is_ok;
  std::string body;

  _DownloadedBodyItem__isset __isset;

  void __set_req_item(const DownloadReqItem& val) {
    req_item = val;
  }

  void __set_prop_item(const DownloadPropItem& val) {
    prop_item = val;
  }

  void __set_is_ok(const bool val) {
    is_ok = val;
  }

  void __set_body(const std::string& val) {
    body = val;
  }

  bool operator == (const DownloadedBodyItem & rhs) const
  {
    if (!(req_item == rhs.req_item))
      return false;
    if (!(prop_item == rhs.prop_item))
      return false;
    if (!(is_ok == rhs.is_ok))
      return false;
    if (!(body == rhs.body))
      return false;
    return true;
  }
  bool operator != (const DownloadedBodyItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DownloadedBodyItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DownloadedBodyItem &a, DownloadedBodyItem &b);

typedef struct _ExtractItem__isset {
  _ExtractItem__isset() : url(false), url_template(false), depth(false), body(false), seed_url(false), referer(false), template_type(false) {}
  bool url;
  bool url_template;
  bool depth;
  bool body;
  bool seed_url;
  bool referer;
  bool template_type;
} _ExtractItem__isset;

class ExtractItem {
 public:

  static const char* ascii_fingerprint; // = "ED43D7CB2156C5A4FCE057ECAAE23949";
  static const uint8_t binary_fingerprint[16]; // = {0xED,0x43,0xD7,0xCB,0x21,0x56,0xC5,0xA4,0xFC,0xE0,0x57,0xEC,0xAA,0xE2,0x39,0x49};

  ExtractItem() : url(), url_template(), depth(0), body(), seed_url(), referer(), template_type((TemplateType::type)0) {
  }

  virtual ~ExtractItem() throw() {}

  std::string url;
  std::string url_template;
  int32_t depth;
  std::string body;
  std::string seed_url;
  std::string referer;
  TemplateType::type template_type;

  _ExtractItem__isset __isset;

  void __set_url(const std::string& val) {
    url = val;
  }

  void __set_url_template(const std::string& val) {
    url_template = val;
  }

  void __set_depth(const int32_t val) {
    depth = val;
  }

  void __set_body(const std::string& val) {
    body = val;
  }

  void __set_seed_url(const std::string& val) {
    seed_url = val;
  }

  void __set_referer(const std::string& val) {
    referer = val;
  }

  void __set_template_type(const TemplateType::type val) {
    template_type = val;
  }

  bool operator == (const ExtractItem & rhs) const
  {
    if (!(url == rhs.url))
      return false;
    if (!(url_template == rhs.url_template))
      return false;
    if (!(depth == rhs.depth))
      return false;
    if (!(body == rhs.body))
      return false;
    if (!(seed_url == rhs.seed_url))
      return false;
    if (!(referer == rhs.referer))
      return false;
    if (!(template_type == rhs.template_type))
      return false;
    return true;
  }
  bool operator != (const ExtractItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ExtractItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ExtractItem &a, ExtractItem &b);

typedef struct _MatchedResultItem__isset {
  _MatchedResultItem__isset() : self_result(false), sub_result_list(false), is_ok(false), err_info(false) {}
  bool self_result;
  bool sub_result_list;
  bool is_ok;
  bool err_info;
} _MatchedResultItem__isset;

class MatchedResultItem {
 public:

  static const char* ascii_fingerprint; // = "7609B1D31BB860963FAAAD9401CD61DA";
  static const uint8_t binary_fingerprint[16]; // = {0x76,0x09,0xB1,0xD3,0x1B,0xB8,0x60,0x96,0x3F,0xAA,0xAD,0x94,0x01,0xCD,0x61,0xDA};

  MatchedResultItem() : is_ok(0), err_info() {
  }

  virtual ~MatchedResultItem() throw() {}

  std::map<std::string, std::vector<std::string> >  self_result;
  std::vector<std::map<std::string, std::vector<std::string> > >  sub_result_list;
  bool is_ok;
  std::string err_info;

  _MatchedResultItem__isset __isset;

  void __set_self_result(const std::map<std::string, std::vector<std::string> > & val) {
    self_result = val;
  }

  void __set_sub_result_list(const std::vector<std::map<std::string, std::vector<std::string> > > & val) {
    sub_result_list = val;
  }

  void __set_is_ok(const bool val) {
    is_ok = val;
  }

  void __set_err_info(const std::string& val) {
    err_info = val;
  }

  bool operator == (const MatchedResultItem & rhs) const
  {
    if (!(self_result == rhs.self_result))
      return false;
    if (!(sub_result_list == rhs.sub_result_list))
      return false;
    if (!(is_ok == rhs.is_ok))
      return false;
    if (!(err_info == rhs.err_info))
      return false;
    return true;
  }
  bool operator != (const MatchedResultItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MatchedResultItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(MatchedResultItem &a, MatchedResultItem &b);

typedef struct _DedupExistItem__isset {
  _DedupExistItem__isset() : is_exists(false), item_info(false) {}
  bool is_exists;
  bool item_info;
} _DedupExistItem__isset;

class DedupExistItem {
 public:

  static const char* ascii_fingerprint; // = "1767FFB0CB3D9275BC64B198AB3B8A8B";
  static const uint8_t binary_fingerprint[16]; // = {0x17,0x67,0xFF,0xB0,0xCB,0x3D,0x92,0x75,0xBC,0x64,0xB1,0x98,0xAB,0x3B,0x8A,0x8B};

  DedupExistItem() : is_exists(0), item_info() {
  }

  virtual ~DedupExistItem() throw() {}

  bool is_exists;
  std::string item_info;

  _DedupExistItem__isset __isset;

  void __set_is_exists(const bool val) {
    is_exists = val;
  }

  void __set_item_info(const std::string& val) {
    item_info = val;
  }

  bool operator == (const DedupExistItem & rhs) const
  {
    if (!(is_exists == rhs.is_exists))
      return false;
    if (!(item_info == rhs.item_info))
      return false;
    return true;
  }
  bool operator != (const DedupExistItem &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DedupExistItem & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(DedupExistItem &a, DedupExistItem &b);



#endif
